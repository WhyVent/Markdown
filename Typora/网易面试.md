### 1 自我介绍

### 2 valotile作用

> 如图左，原始线程的变量保存，要先存在工作内存中，在写入主内存。所以用户可能用到的是脏数据。
>
> 而图右，添加volatile关键字后的线程，变量跳过工作内存直接写入主内存，保证了线程的可见性。![img](https://img-blog.csdnimg.cn/20181205143402855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjE1NzM2,size_16,color_FFFFFF,t_70)

### 3 写个算法题，什么全排列之类的

> 

### 4 tcp4次挥手close_wait什么时候

> **1.TCP三次握手图：**
> ![img](https://img2018.cnblogs.com/blog/1006642/201811/1006642-20181107173642950-1646827265.png)
>
> **2.TCP四次挥手图：**
>
> **![img](https://img2018.cnblogs.com/blog/1006642/201811/1006642-20181107173739696-326178362.png)**

### 5 arraylist. vector. linkList. 说说他们

> ArrayList、Vector和LinkedList类均在java.util包下
>
> ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间来存储，因为数据存储是连续的，所以它们支持用下标来访问元素，索引数据的速度比较快。
>
> 1）ArrayList和Vector都有一个初始化的容量大小，当里面存储的元素超过初始的大小时就需要动态地扩充它们的存储空间，Vector默认扩充为原来的两倍（每次扩充空间的大小可以设置），ArrayList默认扩充为原来的1.5倍（没有提供方法来设置空间扩充的方法）。
>
> 2）ArrayList和Vector最大的区别就是synchronization的使用，没有一个ArrayList的方法是同步的，而Vector的绝大多数方法（如add,insert,remove,set,equals,hashcode）都是直接或间接同步的，所以Vector是线程安全的，ArrayList不是线程安全的。正是由于Vector提供了线程安全的机制，其性能上也要稍逊于ArrayList
>
> 3）LinkedList是采用双向列表来实现的，对数据的索引需要从列表头开始遍历，因此用于随机访问则效率比较低，但是插入元素时不需要对数据进行移动，因此插入效率较高。同时，LinkedList是非线程安全的容器
>
> 对容器的选择：
>
> 当对数据的主要操作是索引或只在集合的末端增加、删除元素时，使用ArrayList或Vector效率比较高，当对数据的操作主要为指定位置或删除操作时，使用LinkedList效率比较高；当在多线程中使用容器时，选用Vector较为安全

### 6 sleep和wait区别

> 1，这两个方法来自不同的类分别是Thread和Object；sleep()不释放同步锁,wait()释放同步锁.sleep(milliseconds)可以用时间指定来使他自动醒过来,如果时间不到你只能调用interreput()来强行打断;wait()可以用notify()直接唤起.
> 2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
> 3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
>    synchronized(x){
>       x.notify()
>      //或者wait()
>    }
>
> 4，sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

### 7 nginx无状态，有状态是什么

> 无状态服务
>
> （1）、是指该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的。
>
> （2）、多个实例可以共享相同的持久化数据。例如：nginx实例，tomcat实例等
>
> （3）、相关的k8s资源有：ReplicaSet、ReplicationController、Deployment等，由于是无状态服务，所以这些控制器创建的pod序号都是随机值。并且在缩容的时候并不会明确缩容某一个pod，而是随机的，因为所有实例得到的返回值都是一样，所以缩容任何一个pod都可以。
>
> 有状态服务
>
> （1）、宠物和牛的类比，农场主的牛如果病了可以丢掉再重新买一头，如果宠物主的宠物病死了是没法找到一头一模一样的宠物的。
>
> 有状态服务 可以说是 需要数据存储功能的服务、或者指多线程类型的服务，队列等。（mysql数据库、kafka、zookeeper等）
>
> （2）、每个实例都需要有自己独立的持久化存储，并且在k8s中是通过申明模板来进行定义。持久卷申明模板在创建pod之前创建，绑定到pod中，模板可以定义多个。

### 8 一致性哈希是什么

> 

### 9 查看端口命令，参数

> **netstat命令参数：**
>
> 　　**-t : 指明显示TCP端口**
>
> 　　**-u : 指明显示UDP端口**
>
> 　　**-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)**
>
> 　　**-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。**
>
> 　　**-n : 不进行DNS轮询，显示IP(可以加速操作)**

### 10 一个大文件，顺序读取和随机读取怎么比较好

> - 顺序访问的数据是连续的。硬盘的磁头是按一定的顺序访问磁片，磁头不做频繁的寻道，这样带来的结果是速度很快。因为寻道时间是影响磁盘读写速度的主要原因。在平常的应用中顺序访问的应用很少。大文件的连续备份，是顺序读写的。dd就是典型的顺序读写，
> - 随机访问主要是磁头在做频繁的移动，原因是数据在磁盘的不连续性，这和数据存放到磁盘的过程有关系，随机访问的速度要比顺序访问慢很多。原因也是因为磁头频繁的寻道，定位，磁头的移动消耗掉很多时间。大部分的应用在磁盘上的读写是随机的。

### 11 线程怎么调度和方法

> 1、sleep()方法——休眠
>
> 线程休眠的方法是：Thread.sleep(long millis) 
>
>                                 Thread.sleep(long millis, int nanos)
>
> 线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。
>
> 2、yield()方法——让步
>
> 线程的让步使用Thread.yield()方法，yield() 为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。如果有多个线程，具体把权限让给谁了，它不知道。
>
> 3、join()方法——合并/联合
>
> 一个线程A在占有CPU资源期间，可以让其他线程调用join()和本线程联合，如B.join()
>
> 我们称A在运行期间联合了B。如果线程A在占有CPU资源期间一旦联合B线程，那么A线程将立刻中断执行，一直等到它联合的线程B执行完毕，A线程再重新排队等待CPU资源，以便恢复执行。如果A准备联合B线程已经结束，那么B.join()不会产生任何效果。

### 12 b树b+树的区别

> 二叉搜索树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于
>
> 走右结点；
>
> B（B-）树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键
>
> 字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
>
> B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
>
> 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
>
> B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率
>
> 从1/2提高到2/3；

### 13 谈谈b+树应用

> **一、B树的应用**
>
> 1、B树大量应用在数据库和文件系统当中。
>
> 它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。
>
> 假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。
>
> 如mongoDB数据库使用，单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）
>
> **二、B+树的应用**
>
> mysql使用B+树作为索引：
>
> B+树相对B树的优点：
>
> ①B+树的所有Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串联起来，遍历叶子节点就能获取全部数据，这样就能进行区间访问了。
>
> ②IO一次读数据是从磁盘上读的，磁盘容量是固定的，取数据量大小是固定的，非叶子节点不存储数据，节点小，磁盘IO次数就少。
>
> **三、红黑树**
>
> 红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。
>
> 如linux中进程的调度用的是红黑树。
> 反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。

### 14 说一下索引，索引为什么快，主键索引和非主键索引的区别，索引一定快吗？

> 在 MySQL 中, 索引是在存储引擎层实现的, 所以并没有统⼀的索引标准, 由于 InnoDB 存储引擎在 MySQL数据库中使⽤最为⼴泛, 下⾯以 InnoDB 为例来分析⼀下其中的索引模型.在 InnoDB 中, 表都是根据主键顺序以索引的形式存放的, InnoDB 使⽤了 B+ 树索引模型，所以数据都是存储在 B+ 树中的, 如图所示:
>
> ![img](https://img-blog.csdnimg.cn/20200117094708639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseV96aGFvaHk=,size_16,color_FFFFFF,t_70)
>
> 从图中可以看出, 根据叶子节点内容不同,索引类型分为主键索引和非主键索引.
> **主键索引**也被称为聚簇索引,叶子节点存放的是整行数据; 
>
> **非主键索引**被称为二级索引,叶子节点存放的是主键的值.
> 如果根据主键查询, 只需要搜索ID这颗B+树
> 而如果通过非主键索引查询, 需要先搜索k索引树, 找到对应的主键, 然后再到ID索引树搜索一次, 这个过程叫做回表.
> 总结, 非主键索引的查询需要多扫描一颗索引树, 效率相对更低.
>
> 

### 15 nginx负载均衡策略

> 当一台服务器的处理能力、存储空间不足时，不要企图去换更强大的服务器，对大型网站而言，不管多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问及存储压力。扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其意思就是分摊到多个操作单元上进行执行。
>
> 　　在这里我们只阐述对请求的的负载均衡。
>
> 　　通过负载均衡调度服务器，将来自浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多的用户，就在集群中加入更多的应用服务器，使应用服务器的负载压力不再成为整个网站的瓶颈。

### 16 如何保证缓存一致性呢

> 

### 17 幂等性是什么，很多请求进来如何限流

> 

### 18 三级缓存是什么。

> 

### 19、汉字占几个char，int和long分别是多少位 

> 

### 20、共享变量 long a当两个线程来读a的时候会发生什么？（当时只说了脏数据，但是不是面试官想要的，面试官继续引导，会出现什么问题，最后再引导下说了long存储的前32bit和后32bit可能不是同时更新，这里还没查long的存储类型，回头查看一下）。

> 

### 21、给了一小段代码然后判断每个变量类加载的时候放在那个区？（方法区啊，栈啊等）

> 

### 22、递归10w次会出现什么？（OOM） 

> 

### 23、数据库的隔离性（然后在可重复读的情况下模拟幻读的情况，我回答了事物重新写进来几个不同的列，不是面试官想要的，继续问，因为平常没关注过这个问题，所以来来回回之说了添加新的列情况。在这一块和面试官聊了一会） 

> 

### 24、手写一个非递归实现的中序遍历。（中间实现的不是很顺利，写成了DFS😅，然后面试官提醒了一下，我就说了下自己的思路，他说可以了，感谢面试官小哥哥）。

25、TCP协议的稳定性体现在哪里？

26、HTTP协议的结构，请求头、请求体。

27、如何查看运行中的线程状态

28、操作系统间的线程切换

29、zookeeper实现分布式锁

30、数据结构，如何创建一个图