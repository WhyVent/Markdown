## 一、个人简介

***

> 您好，我是来自浙江大学电子与通信工程专业的研二学生葛天雄。熟悉C语言与Java。本科专业是电子与通信工程，主要学习嵌入式方面；研究生阶段跟随导师从事物联网方面的研究。无论在本科还是研究生阶段都获得了校奖学金；现担任支部书记，获得过优秀支部委员，与优秀党员。研究生期间参与实验室项目智能仓储物流管理系统的设计与开发，主要负责硬件实现与Android客户端的开发。在这个过程中，我对软件设计越来越感兴趣，特别是服务器开发与设计方面，最近也在学习这方面的知识，所以非常希望能够参与本次的实习，提高这方面的工作经验。

## 二、Java面试题

***

### 1、一个.java源文件中是否可以包括多个类（不是内部类）？有什么限制？

> 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。

### 2、Java有没有goto？

> goto是java语言中的保留字，目前还没有在java中使用。

### 3、&和&&的区别？

> - &和&&都可以用作逻辑与的运算符，表示逻辑与（and）；
> - &&还具有短路的功能；
> - &还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作。

### 4、switch语句能否作用在byte上，能否作用在long上，能否作用在String上？

> 在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。但是在JDK7的新特性中，switch语句可以用字符串。

### 5、short s1 = 1; s1 = s1 + 1;有什么错？short s1 = 1; s1 += 1;有什么错？

> - 对于short s1 = 1; s1 = s1 + 1;由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。
>
> - 对于short s1 = 1; s1 += 1;由于+= 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

### 6、char型变量中能不能存贮一个中文汉字？为什么？

> char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。

### 7、用最有效率的方法算出2乘以8等於几？

> 2 << 3，因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 << 3。

### 8、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

> 使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

### 9、"=="和equals方法究竟有什么区别？

> - ==比较的是值，equals比较的是地址值 
>
> - 一般我们会重写equals让它按照我们的意愿去比较相关属性，而不是单纯的比较地址值。

### 10、静态变量和实例变量的区别？

> ①在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。
>
> ②在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
>
> ③例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。

### 11、是否可以从一个static方法内部发出对非static方法的调用？

> 不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。

### 12、Integer与int的区别

> ①int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。
>
> ②在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。
>
> ③另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。

### 13、Math.round(11.5)等於多少？Math.round(-11.5)等於多少？

> Math类中提供了三个与取整有关的方法：ceil.floor.round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。

### 14、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?

> ①方法重载（Overload）：在本类中出现了方法名相同但参数列表不同的方法，与返回值无关，可以改变返回值类型，只看参数列表；
>
> ②方法重写（Override）：子类中出现了和父类中方法声明一模一样的方法，与返回值有关，返回值和类型都是一样的。

### 15、面向对象的特征有哪些方面？

> ①抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
>
> ②继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。
>
> ③封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。
>
> ④多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：（a） 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；（b）对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

### 16、String是最基本的数据类型吗？

> 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。

### 17、float f=3.4;是否正确？

> 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。

### 18、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法？

> ①通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；
>
> ②而通过new关键字和构造器创建的对象放在堆空间；
>
> ③程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在静态区中。
>
> ④栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。
>
> ⑤例如：String str = new String("hello");
>
> 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量放在静态区。

### 19、数组有没有length()方法？String有没有length()方法？

> 数组没有length()方法，有length的属性。String有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。

### 20、在Java中，如何跳出当前的多重嵌套循环？

> 在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）

### 21、构造器（constructor）是否可被重写（override）？

> 构造器不能被继承，因此不能被重写，但可以被重载。

### 22、两个对象值相同x.equals(y) == true，但却可有不同的hash code，这句话对不对？

> 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：
>
> (1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；
>
> (2)如果两个对象的hashCode相同，它们并不一定相同。
>
> 当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。
>
> 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1.使用==操作符检查"参数是否为这个对象的引用"；2.使用instanceof操作符检查"参数是否为正确的类型"；3.对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4.编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5.重写equals时总是要重写hashCode；6.不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。

### 23、是否可以继承String类？

> String 类是final类，不可以被继承。
>
> 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。

### 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

> 是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。

### 25、String和StringBuilder、StringBuffer的区别？

> （1）String和StringBuffer、StringBuider：
>
>   ①String：是不可变字符序列；
>
>   ②StringBuffer、StringBuider：是可变字符序列；
>
>   ③String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。
>
> （2）StringBuffer和StringBuider：
>
>   ①StringBuffer：是JDK1.0版本的，线程安全，效率低；
>
>   ②StringBuilder：是JDK1.5版本的，线程不安全，效率高；
>
>   ③如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。

### 26、描述一下JVM加载class文件的原理机制？

> JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
>
> 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
>
> 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
>
> Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
>
> Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
>
> System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

### 27、抽象类（abstract class）和接口（interface）有什么异同？

> （1）成员特点：
>
> ①构造方法：接口没有；抽象类有；
>
> ②成员变量：接口中只有常量；抽象类中常量、变量都可；
>
> ③成员方法：接口只有抽象方法；抽象类中抽象方法、非抽象方法都可；
>
> （2）关系特点：
>
> ①类与类：只有单继承，但可以多层继承；
>
> ②类与接口：实现关系，可以单实现，也可以多实现；
>
> ③接口与接口：继承关系，可以单继承，也可以多继承；
>
> （3）设计理念：
>
> ①接口是简单工厂设计模式，like a的关系 ,接口中定义的是该继承体系的扩展功能；
>
> ③抽象类是模板设计模式，is a的关系，抽象类中定义的是继承体系的共性功能；

### 28、Java中会存在内存泄漏吗，请简单描述？

> 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。

### 29、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？

> 都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。

### 30、GC是什么？为什么要有GC？

> GC是垃圾收集的意思，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，从而有效的防止内存泄露。要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntime().gc()，但JVM可以屏蔽掉显示的垃圾回收调用。

### 31、String st = null和 String st =“ ”的区别？String s = new String("xyz")创建了几个对象？

> （1）String st = null表示声明了一个String对象的引用str，但是没有为其分配存内存空间。
>
> （2）String st =“ ”表示创建了一个长度等于0的空字符串，并在内存中分配了内存空间。
>
> （3）String st = new String(“xyz”)；表示创建了两个对象：
>
>    ①堆内存中一个new String；
>
>    ②常量池中一个字符串。

### 32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？

> 接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。

### 33、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？

> 可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。

### 34、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？

> 一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

### 35、final、finally和finalized的区别？

> （1）final：被final修饰的类，不被能继承；被final修饰的方法，不能被重写；被fianl修饰的量，为常量，只能被赋值一次；
>
> （2）finally：异常处理，和try、catch结合使用，可加可不加，用于执行一些必须执行的代码，如释放资源等；
>
> （3）finalized：Object类中的方法，其中定义了对象要被垃圾回收器回收之前，要做的一些清理工作。

### 36、数据类型之间的转换？

> （1）如何将字符串转换为基本数据类型？
>
> 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；
>
> （2）如何将基本数据类型转换为字符串？
>
> 一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String类中的valueOf()方法返回相应字符串

### 37、如何实现字符串的反转及替换？

> 方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：
>
> ```java
> public static String reverse(String originStr) {     
>     if(originStr == null || originStr.length() <= 1)       
>         return originStr;     
>     return reverse(originStr.substring(1)) + originStr.charAt(0);   
> }
> ```

### 38、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？

> String s1 = "你好";
>
> String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");

### 39、比较一下Java和JavaSciprt？

> 其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言：
>
> （1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。
>
> （2）解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）
>
> （3）强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。
>
> （4）代码格式不一样。

### 40、Error和Exception有什么区别？

> ①Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；
>
> ②Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

### 41、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后？

> 会执行，在方法返回调用者前执行。

### 42、throw和throws的区别、及处理方式？

> （1）throw：用于抛出异常对象，后面跟的是异常对象；throw用在方法体内；
>
> （2）throws：用于抛出异常类，后面跟的是异常类名，可以跟多个，用逗号隔开。throws用在方法上
>
> （3）异常处理方式：抛出throws、捕捉try - catch - finally。
>
> （4）什么时候定义try，什么时候定义throws？
>
>    ①功能内部如果出现异常，如果可以处理，就用try；
>
>    ②如果内部处理不了，就必须声明出来，让调用者处理。

### 43、编译时异常和运行时异常的区别？

> （1）编译时异常在函数内被抛出，函数必须声明，否则编译失败。
>
>   声明的原因：是需要调用者对该异常进行处理。必须进行处理，否则无法编译通过；（throws)
>
> （2）运行时异常如果在函数内被抛出，在函数上不需要声明。
>
>   不声明的原因：不需要调用者处理，运行时异常发生，已经无法再让程序继续运行，所以，不让调用处理的，直接让程序停止，由调用者对代码进行修正。（throw)

### 44、List、Set、Map是否继承自Collection接口？

> List、Set是，Map不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。

### 45、阐述ArrayList、Vector、LinkedList的存储性能和特性？

### 46、Collection和Collections的区别？

### 47、List、Map、Set三个接口存取元素时，各有什么特点？

### 48、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？

### 49、Thread类的wait( )和sleep( )的区别？

> （1）所在类不同：wait( )是Object类中的方法；sleep( )是Tread类中的方法；
>
> （2）slepp( )没有释放同步锁，而wait( )释放了同步锁；
>
> （3）slepp( )必须制定时间，而wait( )不用；
>
> （4）slepp( )可以在任何地方使用，而wait( )、notify( )、notifyAll( )只能在同步方法或同步代码块中使用；
>
> （5）slepp( )必须捕获异常，而wait( )、notify( )、notifyAll( )不用；

### 50、线程的sleep()方法和yield()方法有什么区别？

### 51、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

> 不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

### 52、简述线程的五种状态？

### 53、创建多线程的两种方式期区别？

### 54、synchronized关键字的用法？

### 55、举例说明同步和异步。

### 56、启动一个线程是调用run()还是start()方法？

### 57、什么是线程池（thread pool）？

### 58、同步代码块与同步函数的区别？

### 59、Java中如何实现序列化，有什么意义？

### 60、Java中有几种类型的流？

### 61、Statement和PreparedStatement有什么区别？哪个性能更好？

### 62、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？

### 63、在进行数据库编程时，连接池有什么作用？

### 64、什么是DAO模式？

### 65、JDBC中如何进行事务处理？

### 66、获得一个类的类对象有哪些方式？

### 67、如何通过反射创建对象？

### 68、简述一下面向对象的"六原则一法则"？

### 69、简述一下你了解的设计模式？

### 70、用Java写一个单例类？

### 71、线程如何同步和通讯？

### 72、hashCode方法的作用？

### 73、什么是SOA，谈谈你的SOA的理解？

### 74、java中实现多态的机制是什么？

### 75、.super.getClass()方法调用？

### 76、请写出你最常见到的5个runtime exception？

### 77、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?

### 78、简述synchronized和java.util.concurrent.locks.Lock的异同 ？

### 79、HashMap和Hashtable的区别？

### 80、两个对象值相同x.equals(y) == true，但却可有不同的hash code，这句话对不对?

### 81、heap和stack有什么区别？

### 82、传统for循环、增强for循环、及迭代器的区别？

### 83、ArrayList、Vector、LinkedList的区别

### 84、描述一下你最常用的java编程风格

### 85、什么是内存泄漏？

### 86、Static Nested Class 和 Inner Class的不同

### 87、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1

### 88、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?

### 89、请说出你所知道的线程同步的方法

### 90、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?

### 91、线程的基本概念、线程的基本状态以及状态之间的关系

### 92、如果变量用final修饰，则怎样？如果方法final修饰，则怎样？

### 93、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？

### 94、作用域public,private,protected,以及不写时的区别

### 95、Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实 现)interface(接口

### 96、什么时候用assert

### 97、Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何 区别

### 98、abstract class和interface有什么区别

### 99、介绍JAVA 中的Collection FrameWork(包括如何写自己的数据结构)?

### 100、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally 分别代表什么意义？在try 块中可以抛出异常吗？

### 101、请简述你对分布式系统的理解？

> 简单来说就是把一个业务拆成多个子业务，部署在不同的服务器上。
>
> 比如说我开了一家饭店，给客人提供饭菜业务。我可以不招员工全部由我一个人完成，点菜、炒菜、配菜、送菜，来完成这个业务，这就是单一应用架构，这种架构的性能扩展比较困难，也方便协同开发，同时也不利于升级维护。
>
> 我当然也可以招员工，厨师、配菜师、传菜员、服务员，每个人对应不同的子业务，最终把菜送给客人，这就是分布式服务架构，服务之间解耦，相对独立，方便业务扩展。通过分布式的独立部署大大缓解维护工作与数据库访问的压力。模块化开发可以能用到的资源剥离出来，提高资源的高复用性。具体的实现方式可以是dubbo+zookeeper也可以是springcloud。
>
> 而厨师、配菜师、传菜员和服务员都不止一个人，这就是集群；分布式就是微服务的一种表现形式，分布式是部署层面，微服务是设计层面。
>
> **Dubbo是怎么到SpringCloud(谈谈这两个微服务架构)**
>
> **最大区别：**
>
> 1、springcloud抛弃了Dubbo的RPC(远程过程调用)通信机制，采用的是基于HTTP的Rest方式。
>
> 2、需要的技术实现基本上都是自己拥有的框架
>
> 3、社区支持，社区活跃程度：2017年重启了(刘军)，
>
> 总结：严格来说，这两种方式各有优劣，从一定程度上后者牺牲了服务调用的性能，但避免了上面跳到的原生RPC带来的问题，且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在重度依赖

### 102、那分布式系统环境下各自有什么优缺点？

> 优点很多呀，使用分布式不就是为了解决传统架构各种问题嘛，多人在一个下开发维护难，也不好控制容错能力。拆分成微服务问题就好办多了。主要从 4 个方面简单说下。
>
> 1. **系统可用性提升**
>    一个系统全年可用时间在 99.999%，5 个 9 的服务可用率在设计合理的分布式系统中并不是一个触不可及的数字。
>
> 传统的集中式计算或集中式存储在遇见单点故障时很容易造成整个服务不可用，分布式下的服务体系，单台机器有故障，不致于造成整个服务不可用。
>
> 1. **系统并发能力提升**
>    请求通过 Nginx 负载均衡被分发到不同的服务器上，运行同样代码的服务器可以有 1 台或 N 台，通常情况下会根据实际用户访问量随时增加机器，无论是数据库或者服务，都可以做到随时**水平扩展**。
>
> 比如双 11 活动，平时订单少 50 台机器就够了，到了 11 订单量剧增，服务器增加到 100 台，每台机器之间相互独立，互不影响。
>
> 1. **系统容错能力提升**
>    ![图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubXVrZXdhbmcuY29tLzVlMTI5NzRiMDAwMWRmOWEwNTc4MDMzMy5wbmc?x-oss-process=image/format,png)
>
> （手里有笔，能给面试官随便画画）
>
> 同一组服务分别部署在北京上海杭州，杭州的机房突发断电或者火灾，杭州机房的流量会被自动分发到北京和上海的机房，不影响用户使用。
>
> 1. **低延迟**
>    参考上一个图，北京的用户请求自动分发到北京，上海的用户请求被分发到上海，服务器会根据用户的 IP 选择距离自己最近的机房，降低网络延迟。
>
> 面试官：嗯，基本覆盖全面了，继续说说缺点。
>
> 凡事具有两面性，分布式服务带来很多好处的同时肯定还会带来麻烦，主要从 3 方面考虑。
>
> 1. **分布式服务依赖网络**
>    服务器间通讯依赖网络，不可靠网络包括网络延时，丢包、中断、异步，一个完整的服务请求依赖一连串服务调用，任意一个服务节点网络出现问题，都可能造成本次请求失败。
> 2. **维护成本高**
>    传统单体式服务只需要维护一个站点就可以。
>    分布式服务系统被拆分成若干个小服务，服务从 1 变为几十个上百个服务后，增加运维成本。
> 3. **一致性，可用性，分区容错性无法同时满足**
>    这个是最主要的，这三种特性就是平时说的 CAP 定理，在分布式系统中，这三种特性最多只能满足两种，无法同时满足，需要根据实际情况去调整牺牲掉其中哪个。
>
> 面试官：嗯，最主要的第三点意识到了。（面试官心理：如果能意识到 CAP 问题那就好办多了，提到 CAP，那可以继续聊聊）
>
> 成功给自己挖坑，关于 CAP，下一节单独讲解

### 103、列举设计分布式系统需要考虑的问题?

> 1.如何将系统拆分成多个子系统
>
> 2.如何规划子系统的通信问题RPC/HTTP
>
> 3.如何实现通信过程中的安全
>
> 4.如何才能实现子系统的可扩展性
>
> 5.可用性、一致性、分区容错性的权衡（CAP)

### 104、基于web前后端分离的背景，请简述web后端开发的职责是怎样的？

### 105、分布式的事务锁

### 106、REST的API，HTTP1.1和HTTP2.0的区别

### 107、MySQL5.7之后的事务锁

### 108、算法：int[] a={1,-1,0,2,3,4,...}，找出所有没有重复的三个和等于0的数

### 109、函数式编程和面向对象编程的区别？JDK8之后为什么引入函数式编程

> 函数式编程，顾名思义，这种编程是以函数思维做为核心，在这种思维的角度去思考问题。这种编程最重要的基础是λ演算，接受函数当作输入和输出。
> 面向对象编程，这种编程是把问题看作由对象的属性与对象所进行的行为组成。基于对象的概念，以类作为对象的模板，把类和继承作为构造机制，以对象为中心，来思考并解决问题。

### 110、同步锁Synchronized与Lock的区别?

>  1:**Lock**是一个接口，而**Synchronized**是关键字。
>
>  2:**Synchronized**会自动释放锁，而**Lock**必须手动释放锁。
>
>  3:**Lock**可以让等待锁的线程响应中断，而**Synchronized**不会，线程会一直等待下去。
>
>  4:通过**Lock**可以知道线程有没有拿到锁，而**Synchronized**不能。
>
>  5:**Lock**能提高多个线程读操作的效率。
>
>  6:**Synchronized**能锁住类、方法和代码块，而**Lock**是块范围内的

### 111、请解释一下Java多线程回调是什么意思？

> 

